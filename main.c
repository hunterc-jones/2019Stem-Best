#pragma config(Sensor, in2,    elbowPotSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  LeftSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl10, AutoCheck,      sensorTouch)
#pragma config(Sensor, dgtl12, RightSensor,    sensorDigitalIn)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           elbow,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           right,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           wrist,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           pushRod,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ARM control = up/down LEFT gamepad btns
// WRIST control = left/right RIGHT gamepad btns


// Autonomous Vars
long sensorLeft;
long sensorRight;
int sensorAutoCheck;
float MaxSpeed = 0.6;					// CONFIG VAL		for setting highest speed robot can increment to during autonomous
float MinSpeed = -MaxSpeed;
float LeftSpeed;
float RightSpeed;
float increment = 0.05;				// CONFIG VAL		for setting the speed robot makes each iteration during autonomou

// Basis Vars
int driveMode = 0;
bool setupComplete = false;
bool arcadeBtnPressed = false;
bool tankBtnPressed = false;
bool mainautoBtnPressed = false;
bool ralstonvalleyautoBtnPressed = false;
float deadband = 1.0;					// CONFIG VAL to reduce deadband

// Wrist Vars
int wristPos = 0;
int wristDefaultTheta = 45;		// CONFIG VAL		for setting the default/starting position of the wrist servo
int theta = 59;								// CONFIG VAL		for setting int increment made to servo to turn just one cable slot
int minWristPos = 0;
int maxWristPos = 3;
bool minusThetaWristBtnPressed = false;
bool plusThetaWristBtnPressed = false;


void SetupRobot() {
	motor[wrist] = wristDefaultTheta;	// min 40, max -120
}
void CheckDriveModes() {
	if (vexRT[Btn8L] && !arcadeBtnPressed) {
		driveMode = 0;
		arcadeBtnPressed = true;
	} else if (!vexRT[Btn8L]) {
		arcadeBtnPressed = false;
	}
	if (vexRT[Btn8R] && !tankBtnPressed) {
		driveMode = 1;
		tankBtnPressed = true;
	} else if (!vexRT[Btn8R]) {
		tankBtnPressed = false;
	}
	if (vexRT[Btn8U] && !mainautoBtnPressed) {
		driveMode = 2;
		mainautoBtnPressed = true;
	} else if (!vexRT[Btn8U]) {
		mainautoBtnPressed = false;
	}
	if (vexRT[Btn8D] && !ralstonvalleyautoBtnPressed) {
		driveMode = 3;
		ralstonvalleyautoBtnPressed = true;
	} else if (!vexRT[Btn5D]) {
		ralstonvalleyautoBtnPressed = false;
	}
}
void ChangeWristPos() {
	motor[wrist] = wristDefaultTheta+(wristPos*-theta);
}
void Wrist() {
	if (vexRT[Btn7L] && !minusThetaWristBtnPressed) {
		if (wristPos > minWristPos) {
			wristPos--;
			ChangeWristPos();
		}
		minusThetaWristBtnPressed = true;
	} else if (!vexRT[Btn7R]) {
		plusThetaWristBtnPressed = false;
	}
	if (vexRT[Btn7R] && !plusThetaWristBtnPressed) {
		if (wristPos < maxWristPos) {
			wristPos++;
			ChangeWristPos();
		}
		plusThetaWristBtnPressed = true;
	} else if (!vexRT[Btn7L]) {
		minusThetaWristBtnPressed = false;
	}
}
void Arm() {		// function for arm and elbow (elbow if configured for Corbin's design)
	if (vexRT[Btn6D]) {
		motor[arm] = 127.0;		// moves arm down
	} else if (vexRT[Btn6U]) {
		motor[arm] = -127;		// moves arm up
	} else {
		motor[arm] = 0;				// stops arm
	}
}
void Arcade() {
	if (abs(vexRT[Ch2] - vexRT[Ch1]) > deadband) {
		motor[right] = vexRT[Ch2] - vexRT[Ch1];
		} else {
		motor[right] = 0;
	}
	if (abs(vexRT[Ch1] + vexRT[Ch2]) > deadband) {
		motor[left] = vexRT[Ch1] + vexRT[Ch2];
		} else {
		motor[left] = 0;
	}
	Arm();
	Wrist();
}
void Tank() {
	if (abs(vexRT[Ch3]) > deadband) { // Checks value of left joystick to see if it's outside of deadband
		motor[left] = vexRT[Ch3];
		} else {
		motor[left] = 0;
	}
	if (abs(vexRT[Ch2]) > deadband) {
		motor[right] = vexRT[Ch2];
		} else {
		motor[right] = 0;
	}
	Arm();
	Wrist();
}
bool sensorCheck(long sens) {
	return (sens > 0.5);
}
void GetSensorReadout() {
	sensorLeft = SensorValue[LeftSensor];
	sensorRight = SensorValue[RightSensor];
	sensorAutoCheck = SensorValue[AutoCheck];
}
float MotorCheck(float speed, float change) {
	speed += change;
	if (speed > MaxSpeed) {
		speed = MaxSpeed;
	} else if (speed < MinSpeed) {
		speed = MinSpeed;
	}
	return speed;
}
void PathFinishedReset() {
	motor[left] = 0;
	motor[right] = 0;
}
void RalstonValleyAuto() {
	GetSensorReadout();
	if (SensorValue[sensorAutoCheck] == 1) {
		PathFinishedReset();
	} else {
		motor[left] = 127;
		motor[right] = 127;
	}
}
void MainAuto() {
	GetSensorReadout();
	if (SensorValue[sensorAutoCheck] == 1) {
		PathFinishedReset();
	} else {
		if (sensorCheck(sensorLeft) && sensorCheck(sensorRight)) {		// If both are detecting black
			LeftSpeed = MotorCheck(LeftSpeed, increment);
			RightSpeed = MotorCheck(RightSpeed, increment);
		} else if (sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){	// If only left is detcting black
			LeftSpeed = MotorCheck(LeftSpeed, -increment);
			RightSpeed = MotorCheck(RightSpeed, increment);
		} else if (!sensorCheck(sensorLeft) && sensorCheck(sensorRight)){	// If only right is detecting black
			LeftSpeed = MotorCheck(LeftSpeed, increment);
			RightSpeed = MotorCheck(RightSpeed, -increment);
		} else if (!sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){		// If neither are detecting black
			LeftSpeed = MotorCheck(LeftSpeed, -increment);
			RightSpeed = MotorCheck(RightSpeed, -increment);
		}
		motor[left] = LeftSpeed * 127;
		motor[right] = RightSpeed * 127;
	}
}


task main() {
	if (!setupComplete) {
		SetupRobot();
		setupComplete = true;
	}
	while (true) {
		// Checks for button presses and sets drive mode accordingly
		CheckDriveModes();
		switch (driveMode) { // Checks what drive mode is set to and runs drive function based on that
		case 0:
			Arcade();
			break;
		case 1:
			Tank();
			break;
		case 2:
			MainAuto();
			break;
		case 3:
			RalstonValleyAuto();
			break;
		}
	}
}
