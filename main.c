#pragma config(Sensor, dgtl2,  LeftSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl6,  MidSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl10, AutoCheck,      sensorTouch)
#pragma config(Sensor, dgtl12, RightSensor,    sensorDigitalIn)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           right,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           wrist,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           condAct,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           pushRod,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

long L;
long B;
long R;
int wristServoPos = 1;
float deadband = 1;
float condActMotorSpeed = 90;
float MaxSpeed = 0.3;
float MinSpeed = -0.3;
float LeftSpeed = 0.0;
float RightSpeed = 0.0;
float increment = 0.05;
bool arcadeDrive = false;
bool prepareRobotForPath = true;
bool testing = false;
bool doAuto = false;
bool clawOpen = false;
bool pathFinished = false;
bool plus90WristDegBtnPressed = false;
bool minus90WristDegBtnPressed = false;
bool testBtnPressed = false;
bool clawBtnPressed = false;
bool arcadeDriveBtnPressed = false;
bool autoModeBtnPressed = false;
bool hasDirection = false;
bool goRight =  true;
bool onLine = false;



//----------------------------------------------------------------------------------------------------------------------------------
//Motor Controls:
//----------------------------------------------------------------------------------------------------------------------------------

// 1-Joystick Arcade Drive
void ArcadeDrive(){
	if (abs(vexRT[Ch3] + vexRT[Ch4]) > deadband) {	// checks if joystick value is outside of deadband
		motor[left] = vexRT[Ch3] + vexRT[Ch4];				// converts joystick value to the left motor if it is
	} else {
		motor[left] = 0;															// sets the left motor to zero if it isn't
	}
	if (abs((-vexRT[Ch3]) + vexRT[Ch4]) > deadband) {	// does the same for the other side of the joystick and the other motor
		motor[right] = -vexRT[Ch3] +vexRT[Ch4];		// + - symbols are flipped is to reverse the right motor
	} else {
		motor[right] = 0;
	}
}

// 2-Joystick Tank Drive
void TankDrive(){
	if (abs(vexRT[Ch3]) > deadband) {		// Checks if left joystick value is outside of deadband
		motor[left] = vexRT[Ch3];					// Converts left joystick value to left motor value if it is
	} else {
		motor[left] = 0;									// Sets the left motor to zero if it is not
	}
	if (abs(vexRT[Ch2]) > deadband) {		// Checks if the right joystick vale is outside of deadband
		motor[right] = -vexRT[Ch2];				// Converts right joystick value to right motor value if it is (negative for right motor)
	} else {
		motor[right] = 0;									// Sets the right motor to zero if it is not
	}
}

// 2-btn Arm Motor Control
void Arm(){
	if (vexRT[Btn8D]) {					// Checks if the bottom button on the right side of the controller is being pressed
		motor[arm] = 127.0;				// Sets the arm servo to full power if the button is being pressed
	} else if (vexRT[Btn8U]) {	// Checks if the top button on the right side of the controller is being pressed instead
		motor[arm] = -127;				// Sets the arm servo to full reverse power if the button is being pressed
	} else {
		motor[arm] = 0;						// If neither button is being pressed, the arm servo is set to 0 and stops moving
	}
}

// 2-Btn Conduit Motor Control
void Conduit(){
	if (vexRT[Btn5U]) {					// Checks if the upper left trigger button on the controller is being pressed
		motor[condAct] = 90;			// Sets the conduit servo to 70% power if the button is being pressed
	} else if (vexRT[Btn6U]) {	// Checks if the upper right trigger button is being pressed instead
		motor[condAct] = -90;			// Sets the conduit servo to 70% reverse power if the button is being pressed
	} else {
		motor[condAct] = 0;				// If neither button is being pressed, the conduit servo is set to 0 and stops moving.
	}
}

//----------------------------------------------------------------------------------------------------------------------------------


void ChangeWristServoPos() {
	if (wristServoPos < 0) {
		wristServoPos = 0;
	} else if (wristServoPos > 2) {
		wristServoPos = 2;
	}
	switch (wristServoPos) {
		case 0:
			motor[wrist] = -110;
			break;
		case 1:
			motor[wrist] = 0;
			break;
		case 2:
			motor[wrist] = 100;
			break;
	}
}

void ResetRobot() {
	prepareRobotForPath = true;
	motor[left] = 0;
	motor[right] = 0;
	motor[wrist] = 0;
	motor[pushRod] = 0;		// reset to default backward position
}

void PrepareRobotForPath() {
	wristServoPos = 0;
	ChangeWristServoPos();
	motor[claw] = 0;
	prepareRobotForPath = false;
}

bool sensorCheck(long sens) {
    return (sens < 0.5);
}
float MotorCheck(float speed, float min, float max, float change) {
   speed += change;
   if (speed > max) {
       speed = max;
   } else if (speed < min) {
       speed = min;
   }
   return speed;
}


task main()
{
	ResetRobot();
	while(true){
		// 1-Btn Toggle Testing Mode On/Off
		if (false) { //vexRT[Btn8R] && testBtnPressed == false) {
			if (testing == true) {
				testing = false;
				testBtnPressed = true;
			} else if (testing == false) {
				testing = true;
				testBtnPressed = true;
			}
		}
		if (!vexRT[Btn8R]) {
			testBtnPressed = false;
		}


		// 1-Btn Toggle Arcade Drive or Tank Drive
		if (vexRT[Btn5D] && arcadeDriveBtnPressed == false) {
			if (arcadeDrive) {
				arcadeDrive = false;
				arcadeDriveBtnPressed = true;
			} else if (!arcadeDrive) {
				arcadeDrive = true;
				arcadeDriveBtnPressed = true;
			}
		}
		if (!vexRT[Btn5D] && arcadeDriveBtnPressed) {
			arcadeDriveBtnPressed = false;
		}


		// 1-Btn Toggle Autonomous Mode On/Off
		if (vexRT[Btn6D] && autoModeBtnPressed == false) {
			if (!doAuto) {
				doAuto = true;
				autoModeBtnPressed = true;
			} else if (doAuto) {
				doAuto = false;
				autoModeBtnPressed = true;
			}
		}
		if (!vexRT[Btn6D] && autoModeBtnPressed) {
			autoModeBtnPressed = false;
		}

		// Main Robot Operating Logic
		if (testing == false) {	// if not testing




// 2-Btn Wrist Servo Turning
			if (vexRT[Btn7R] && !minus90WristDegBtnPressed) {
				wristServoPos--;
				ChangeWristServoPos();
				minus90WristDegBtnPressed = true;
			}
			if (vexRT[Btn7L] && !plus90WristDegBtnPressed) {
				wristServoPos++;
				ChangeWristServoPos();
				plus90WristDegBtnPressed = true;
			}
			if (!vexRT[Btn7L]) {
				plus90WristDegBtnPressed = false;
			}
			if (!vexRT[Btn7R]) {
				minus90WristDegBtnPressed = false;
			}





			// 2-Btn Servo Claw Control
			if (vexRT[Btn8L] && clawBtnPressed == false) {
				if (clawOpen) {
					motor[claw] = -127;
					clawOpen = false;
					clawBtnPressed = true;
				} else if (!clawOpen) {
					motor[claw] = 127;
					clawOpen = true;
					clawBtnPressed = true;
				}
			} else if (!vexRT[Btn8L] && clawBtnPressed) {
				clawBtnPressed = false;
			}





			// 2-IR Sensor Autonomous Drive
      if (doAuto == true) {
      	while (!hasDirection) {
      		if (vexRT[Btn8L]) {
      			goRight = false;
      			hasDirection = true;
      		}
      		if (vexRT[Btn8R])  {
      			goRight = true;
      			hasDirection = true;
      		}
      	}
      	while (false){//!onLine) {
      		L = SensorValue[LeftSensor];
					B = SensorValue[MidSensor];
        	R = SensorValue[RightSensor];
        	onLine = sensorCheck(L) && sensorCheck(R);

      	}
      	L = SensorValue[LeftSensor];
				B = SensorValue[MidSensor];
        R = SensorValue[RightSensor];
        if (pathFinished == false) {
        	pathFinished = (bool)SensorValue[AutoCheck];// If path has not been completely traveled
        	if (prepareRobotForPath == true) {
        		PrepareRobotForPath();
        	}
					if (sensorCheck(L) && sensorCheck(R)) {		// If both are detecting white
          	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
          	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
          } else if (sensorCheck(L) && !sensorCheck(R)){	// If only left is detcting white
          	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
          	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
          } else if (!sensorCheck(L) && sensorCheck(R)){	// If only right is detecting white
          	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
          	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
          } else {		// If neither are detecting white
          	if ((sensorCheck(B) && !sensorCheck(L)) && (!sensorCheck(R))) {
          		pathFinished = true;
          	} else {
          		LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
          		RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
          	}
        	}
          motor[left] = LeftSpeed*127;
          motor[right] = RightSpeed*127;
        } else {		// If path has been completely traveled
       		ResetRobot();
        	doAuto = false;
       	}
			}


		// Robot Code Prototype Testing Mode
		} else {	// if testing is true
			/*
			if (vexRT[Btn5U]) {
				motor[condAct] = condActMotorSpeed;
			} else if (vexRT[Btn6U]) {
				motor[condAct] = -condActMotorSpeed;
			} else {
				motor[condAct] = 0;
			}
			*/
		}
	}
}
