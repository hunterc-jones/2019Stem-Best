#pragma config(Sensor, in2,    elbowPotSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  LeftSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl10, AutoCheck,      sensorTouch)
#pragma config(Sensor, dgtl12, RightSensor,    sensorDigitalIn)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           elbow,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           right,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           wrist,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           pushRod,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//IR Variables
long sensorLeft;
long sensorRight;
float MaxSpeed = 0.3;
float MinSpeed = -MaxSpeed;
float LeftSpeed = 0.0;
float RightSpeed = 0.0;
float increment = 0.05;
bool pathFinished = false;
//End IR Variables

//Control Foundation Variables
int driveMode = 0;			//	CONFIG VAL		for robot default initial driving mode (arcade, tank, 2-auto, 1-auto)

//Arm Subsystem Controls
bool usingElbow = true;		//CONFIG VAL 		to false for Kyle's prototype
int wristPos = 1;
int theta = 12;					// CONFIG VAL 		to rotate servo by arc length of one wire-holder's diameter
int minWristPos = 0;		// 		no need to config as non-zero, unless claw can move backwards from starting default pos
int maxWristPos = 4;		// CONFIG VAL 		to determine the maximum amount of servo-theta increments allowed for claw
bool minusThetaWristBtnPressed = false;
bool plusThetaWristBtnPressed = false;
float elbowPot = 0.0;
bool deployElbow = false;
bool elbowCheck = true;
float deadband = 1.0;		// CONFIG VAL to reduce deadband



void ChangeWristPos() {
	motor[wrist] = wristPos*theta;
}
void Wrist() {
	if (vexRT[Btn8R] && !minusThetaWristBtnPressed) {
		if (wristPos < minWristPos) {
			wristPos--;
			ChangeWristPos();
		}
		minusThetaWristBtnPressed = true;
	}
	if (vexRT[Btn8L] && !plusThetaWristBtnPressed) {
		if (wristPos < maxWristPos) {
			wristPos++;
			ChangeWristPos();
		}		
		plusThetaWristBtnPressed = true;
	}
	if (!vexRT[Btn8L]) {
		plusThetaWristBtnPressed = false;
	}
	if (!vexRT[Btn8R]) {
		minusThetaWristBtnPressed = false;
	}
}
void Arm() {		// function for arm and elbow (elbow if configured for Corbin's design)
	if (vexRT[Btn7D]) {
		motor[arm] = 127.0;		// moves arm down
	} else if (vexRT[Btn7U]) {
		motor[arm] = -127;		// moves arm up
	} else {
		motor[arm] = 0;				// stops arm
	}		
	if (usingElbow) {		// if robot init var "usingElbow" is set to true for Corbin's design
		if (vexRT[Btn8U]) deployElbow = true;
		if (vexRT[Btn8D]) deployElbow = false;
		elbowPot = SensorValue[elbowPotSensor];
		if (deployElbow) {
			elbowCheck = false; //This var is used to turn the motor off after the elbow returns to default state to save battery.
			motor[elbow] = (elbowPot - 2716) /12; 
			//This uses a variable difference concept, the further the elbow is from the target, the faster it moves towards it.
		} else {
			if (!elbowCheck) { //If the elbow has not yet been returned to the
				if (elbowPot > 1000) { //Used to slow the motor down so it dosen't slam into the robot
					motor[elbow] = -15;
				} else {
					motor[elbow] = 8;
				}
				elbowCheck = elbowPot - 4094 > -20;
			} else {
					motor[elbow] = 0;
			}
		}
	}
}
void ConstControls() {
	Arm();
	Wrist();		// really means the theta-incremental wrist-claw needed for Corbin and Kyle's designs
}
/*
void EndConstControls() {

}
*/
void Arcade() {
	if (abs(vexRT[Ch3] - vexRT[Ch4]) > deadband) {
		motor[right] = vexRT[Ch3] - vexRT[Ch4];
		} else {
		motor[right] = 0;
	}
	if (abs(vexRT[Ch4] + vexRT[Ch3]) > deadband) {
		motor[left] = vexRT[Ch4] + vexRT[Ch3];
		} else {
		motor[left] = 0;
	}
	ConstControls(); //Called at the end of arcade inorder to do functions like arm movements
}
void Tank() {
	if (abs(vexRT[Ch3]) > deadband) { //Checks value of left joystick to see if it's outside of deadband
		motor[left] = vexRT[Ch3];
		} else {
		motor[left] = 0;
	}
	if (abs(vexRT[Ch2]) > deadband) {
		motor[right] = vexRT[Ch2];
		} else {
		motor[right] = 0;
	}
	ConstControls(); //Called at the end of tank inorder to do functions like arm movements
}










//Begin auto functions
bool sensorCheck(long sens) {
	return (sens < 0.5);
}
float MotorCheck(float speed, float min, float max, float change) {
	speed += change;
	if (speed > max) {
		speed = max;
		} else if (speed < min) {
		speed = min;
	}
	return speed;
}

void Auto() {
	sensorLeft = SensorValue[LeftSensor];
	sensorRight = SensorValue[RightSensor];

	if (sensorCheck(SensorValue[AutoCheck]) == 1) {
		pathFinished = true;
		motor[left] = 0;
		motor[right] = 0;
		driveMode = 4;
		} else {
		if (sensorCheck(sensorLeft) && sensorCheck(sensorRight)) {		// If both are detecting white
			LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
			RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
			} else if (sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){	// If only left is detcting white
			LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
			RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
			} else if (!sensorCheck(sensorLeft) && sensorCheck(sensorRight)){	// If only right is detecting white
			LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
			RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
			} else {		// If neither are detecting white
			LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
			RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
		}
		motor[left] = LeftSpeed * 127;
		motor[right] = RightSpeed * 127;
	}
}

void SingleAuto() {
	sensorLeft = SensorValue[LeftSensor];
	sensorRight = SensorValue[RightSensor];
	if (sensorCheck(SensorValue[AutoCheck]) == 1) {
		pathFinished = true;
		motor[left] = 0;
		motor[right] = 0;
		driveMode = 4;
		} else {
		if (sensorCheck(sensorLeft)) {
			LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
			RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
			} else {
			LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
			RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
		}
		motor[left] = LeftSpeed * 127;
		motor[right] = RightSpeed * 127;
	}
}

void finishedLine() {
	driveMode = 0;
}
//End auto functions

task main() {
	while (true) {
		//Checks for button presses and sets drive mode accordingly
		if(vexRT[Btn5U]) driveMode = 0;		// Arcade
			if(vexRT[Btn6U]) driveMode = 1;		// Tank
			if(vexRT[Btn6D]) driveMode = 2;		// SingleAuto (uses left IR sensor)
			if(vexRT[Btn5D]) driveMode = 3;		// Auto (normal auto, uses left and right IR sensor)

		switch (driveMode) { //Checks what drive mode is set to and runs drive function based on that
		case 0:
			Arcade();
			break;
		case 1:
			Tank();
			break;
		case 2:
			//Auto();
			SingleAuto();
			break;
		case 3:
			Auto();
			break;
		case 4:
			finishedLine();
			break;
		}
	}
}
