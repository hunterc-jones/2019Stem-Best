#pragma config(Sensor, in2,    elbowPotSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  LeftSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl6,  MidSensor,      sensorDigitalIn)
#pragma config(Sensor, dgtl10, AutoCheck,      sensorTouch)
#pragma config(Sensor, dgtl12, RightSensor,    sensorDigitalIn)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           elbow,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           right,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           wrist,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           condAct,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           pushRod,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//IR Variables
long sensorLeft;
long sensorMid;
long sensorRight;
float MaxSpeed = 0.3;
float MinSpeed = -0.3;
float LeftSpeed = 0.0;
float RightSpeed = 0.0;
float increment = 0.05;
bool pathFinished = false;
//End IR Variables

//Control Foundation Variables
int driveMode = 0;

//Arm Subsystem Controls
int wristServoPos = 1;
bool clawOpen = false;
bool clawBtnPressed = false;
bool minus90WristDegBtnPressed = false;
bool plus90WristDegBtnPressed = false;
float elbowPot = 0.0;
bool deployElbow = false;
bool elbowCheck = true;
float deadband = 1.0;

void ChangeWristServoPos() {
	if (wristServoPos < 0) {
		wristServoPos = 0;
	} else if (wristServoPos > 2) {
		wristServoPos = 2;
	}
	switch (wristServoPos) {
		case 0:
			motor[wrist] = -110;
			break;
		case 1:
			motor[wrist] = 0;
			break;
		case 2:
			motor[wrist] = 100;
			break;
	}
}

void Wrist() {
	if (vexRT[Btn7R] && !minus90WristDegBtnPressed) {
		wristServoPos--;
		ChangeWristServoPos();
		minus90WristDegBtnPressed = true;
	}
	if (vexRT[Btn7L] && !plus90WristDegBtnPressed) {
		wristServoPos++;
		ChangeWristServoPos();
		plus90WristDegBtnPressed = true;
	}
	if (!vexRT[Btn7L]) {
		plus90WristDegBtnPressed = false;
	}
	if (!vexRT[Btn7R]) {
		minus90WristDegBtnPressed = false;
	}
}

void Claw() {
	if (vexRT[Btn7U] && clawBtnPressed == false) {
		if (clawOpen) {
			motor[claw] = -127;
			clawOpen = false;
			clawBtnPressed = true;
		} else {
			motor[claw] = 127;
			clawOpen = true;
			clawBtnPressed = true;
		}
	} else if (!vexRT[Btn7U] && clawBtnPressed) {
		clawBtnPressed = false;
	}
}

void Arm() {
	if (vexRT[Btn6D]) {
		motor[arm] = 127.0;
	} else if (vexRT[Btn6U]) {
		motor[arm] = -127;
	} else {
		motor[arm] = 0;
	}
	if (vexRT[Btn5U]) deployElbow = true;
		if (vexRT[Btn5D]) deployElbow = false;

		elbowPot = SensorValue[elbowPotSensor];

		if (deployElbow) {
			elbowCheck = false;
			//motorOutput = (elbowPot - 2716) /12;
			motor[elbow] = (elbowPot - 2716) /12;
		} else {
			if (!elbowCheck) {
				if (elbowPot> 1000) {
					motor[elbow] = -15;
				} else {
					motor[elbow] = 8;
				}
				elbowCheck = elbowPot - 4094 > -20;
			} else {
				motor[elbow] = 0;
			}
		}
}

void ConstControls() {
	Claw();
	Arm();
	Wrist();
}

void EndConstControls() {

}

void Arcade() {
	if (abs(vexRT[Ch3] - vexRT[Ch4]) > deadband) {
		motor[right] = vexRT[Ch3] - vexRT[Ch4];
	} else {
		motor[right] = 0;
	}
	if (abs(vexRT[Ch4] + vexRT[Ch3]) > deadband) {
		motor[left] = vexRT[Ch4] + vexRT[Ch3];
	} else {
		motor[left] = 0;
	}
	ConstControls(); //Called at the end of arcade inorder to do functions like arm movements
}

void Tank() {
	if (abs(vexRT[Ch3]) > deadband) { //Checks value of left joystick to see if it's outside of deadband
		motor[left] = vexRT[Ch3];
	} else {
		motor[left] = 0;
	}
	if (abs(vexRT[Ch2]) > deadband) {
		motor[right] = vexRT[Ch2];
	} else {
		motor[right] = 0;
	}
	ConstControls(); //Called at the end of tank inorder to do functions like arm movements
}

//Begin auto functions
bool sensorCheck(long sens) {
    return (sens < 0.5);
}
float MotorCheck(float speed, float min, float max, float change) {
   speed += change;
   if (speed > max) {
       speed = max;
   } else if (speed < min) {
       speed = min;
   }
   return speed;
}

void Auto() {
	sensorLeft = SensorValue[LeftSensor];
	sensorRight = SensorValue[RightSensor];

	if (false)/*sensorCheck(SensorValue[AutoCheck]))*/ {
		pathFinished = true;
		motor[left] = 0;
		motor[right] = 0;
		driveMode = 3;
	} else {
		if (sensorCheck(sensorLeft) && sensorCheck(sensorRight)) {		// If both are detecting white
	  	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
	  	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
	  } else if (sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){	// If only left is detcting white
	  	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
	  	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
	  } else if (!sensorCheck(sensorLeft) && sensorCheck(sensorRight)){	// If only right is detecting white
	  	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
	  	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
	  } else {		// If neither are detecting white
	  	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
	  	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
		}
		motor[left] = LeftSpeed * 127;
		motor[right] = RightSpeed * 127;
	}
}

void SingleAuto() {
	sensorLeft = SensorValue[LeftSensor];
	sensorRight = SensorValue[RightSensor];
	if (false)/*sensorCheck(SensorValue[AutoCheck]))*/ {
		pathFinished = true;
		motor[left] = 0;
		motor[right] = 0;
		driveMode = 3;
	} else {
		if (sensorCheck(sensorLeft)) {
	  	LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, increment);
	  	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, -increment);
		} else {
			LeftSpeed = MotorCheck(LeftSpeed, MinSpeed, MaxSpeed, -increment);
	  	RightSpeed = MotorCheck(RightSpeed, MinSpeed, MaxSpeed, increment);
		}
		motor[left] = LeftSpeed * 127;
		motor[right] = RightSpeed * 127;
	}
}

void finishedLine() {
	driveMode = 0;
}
//End auto functions

task main() {
	while (true) {
		//Checks for button presses and sets drive mode accordingly
		if(vexRT[Btn8L]) driveMode = 0;
		if(vexRT[Btn8R]) driveMode = 1;
		if(vexRT[Btn8U]) driveMode = 2;

		switch (driveMode) { //Checks what drive mode is set to and runs drive function based on that
			case 0:
				Arcade();
				break;
			case 1:
				Tank();
				break;
			case 2:
				//Auto();
				SingleAuto();
				break;
			case 3:
				finishedLine();
				break;
		}
	}
}
