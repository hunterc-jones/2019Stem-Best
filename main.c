#pragma config(Sensor, in2,    elbowPotSensor, sensorPotentiometer)
#pragma config(Sensor, dgtl2,  LeftSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl10, AutoCheck,      sensorTouch)
#pragma config(Sensor, dgtl12, RightSensor,    sensorDigitalIn)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           elbow,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           right,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           wrist,         tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           pushRod,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
 - Autonomous Variables -
Debug values
By assigning important values to variables we can visualise them with the testing enviorment. This allows for greater testing.
These should always be assigned and equal to their respective sensors but should not be used in place of their regular sensors
*/
long sensorLeft;
long sensorRight;
int sensorAutoCheck;

float MaxSpeed = 0.6;					// CONFIG VAL		for setting highest speed robot can increment to during autonomous
float MinSpeed = -MaxSpeed; //Forwards and backwords should generaly behave identically during IR drive, however this can be changed if a different value increases preformance
// The following two variables represent the speed the autonomous drive wants the motors to be set to. It ranges between 0 and 1
float LeftSpeed;
float RightSpeed;
float increment = 0.05;				// CONFIG VAL		for setting the robots change in speed each iteration during autonomous


// - Basis Variables -
float deadband = 1.0;					// CONFIG VAL   deadband controls the lowest threshold of value to ignore from inputs to reduce pointless motor drain.
int driveMode = 0; /* A variable that stores which sets of inputs controls our robot
0 is Arcade
1 is Tank
2 is Normal Autonomous
3 is Alternative Autonomous(Also refered to as direct direction autonomous)
*/
bool setupComplete = false; //A boolean variable that stores if initial setup has been completed.
//Button Variables
/*
A button variable is a boolean variable employed to remember the recent activation status of a button used to control a drive mode.
Each of these functions serve a similar purpose but vary based on their drive mode.
These buttons inhabit the four "8" buttons, with 8L being arcade, 8R being tank, 8U being main auto, 8D being alternative auto.
*/
bool arcadeBtnPressed = false; //The first "button variable", arcadeBtnPressed is used to remember the Arcade drive's activation button, 8L
bool tankBtnPressed = false; //The second "button variable", tankBtnPressed is used to remember the Tank drive's activation button, 8R
bool mainautoBtnPressed = false; // The third "button variable" mainautoBTNPressed is used to remember the Main Automatic drive's activation button, 8U
bool AlternativeAutoBtnPressed = false; // The third "button variable" AlternativeAutoBTNPressed is used to remember the Alternative Automatic drive's activation button, 8D


// Wrist Variables
int wristPos = 0; // Current value the wrist should be holding
int wristDefaultTheta = 45;		// CONFIG VAL		for setting the default/starting position of the wrist servo
int theta = 59;								// CONFIG VAL		for setting integer increment made to servo to turn
int minWristPos = 0; // This is the minumim value the wrist is allowed to take
int maxWristPos = 3; // This is the maximum value the wrist is allowed to take
//We have two button variables for our wrist that work similarly to our button variables that set our drive move. They remember whether the lower or raise buttons were held.
bool minusThetaWristBtnPressed = false; // A boolean that represents if the button that lowers our wrist is pressed
bool plusThetaWristBtnPressed = false; // A boolean that represents if the button that raise our wrist is pressed


void SetupRobot() {
	motor[wrist] = wristDefaultTheta;	// min 40, max -120
}

void CheckDriveModes() {//This method changes the drive mode variable in accordance with what buttons are currently pressed.

	// Each if Statement uses the logic that if the button for an input system was not recently pressed, but it is pressed at this moment, activate said mode

	if (vexRT[Btn8L] && !arcadeBtnPressed) {//Arcade mode activation
		driveMode = 0;
		arcadeBtnPressed = true;
	} else if (!vexRT[Btn8L]) {
		arcadeBtnPressed = false;
	}

	if (vexRT[Btn8R] && !tankBtnPressed) {//Tank mode activation
		driveMode = 1;
		tankBtnPressed = true;
	} else if (!vexRT[Btn8R]) {
		tankBtnPressed = false;
	}
	if (vexRT[Btn8U] && !mainautoBtnPressed) {{//Main Autonomous Activation
		driveMode = 2;
		mainautoBtnPressed = true;
	} else if (!vexRT[Btn8U]) {
		mainautoBtnPressed = false;
	}
	if (vexRT[Btn8D] && !alternativeAutoBtnPressed) {//Alternative Autonomous Activation
		driveMode = 3;
		alternativeAutoBtnPressed = true;
	} else if (!vexRT[Btn5D]) {
		alternativeAutoBtnPressed = false;
	}
}

//ChangeWristPos is what defines a new wrist position which our wrist will try to obtain.
void ChangeWristPos() {
	motor[wrist] = wristDefaultTheta+(wristPos*-theta); /// Our servo should be set to our default positoin plus how many times we want to increase our position times by how powerfull each change in position should be.
}

void Wrist() { //This system controlls all wrist movement for manipulating game objects as our drivers need. If a drive mode should have the wrist controlled by a driver, then this method should be called
	if (vexRT[Btn7L] && !minusThetaWristBtnPressed) { //Determines if the wrist position should be changed negatively
		if (wristPos > minWristPos) { //We should not lower the wrist below the minimum. This insures that once the value is below the minimum it does not retract
			wristPos--;
			ChangeWristPos();
		}
		minusThetaWristBtnPressed = true;
	} else if (!vexRT[Btn7R]) {
		plusThetaWristBtnPressed = false;
	}
	if (vexRT[Btn7R] && !plusThetaWristBtnPressed) { //Determines if the wrist position should be changed positively
		if (wristPos < maxWristPos) { //We should not raise wrist above the maximum. This insures that once the value is above the maximum it does not extend
			wristPos++;
			ChangeWristPos();
		}
		plusThetaWristBtnPressed = true;
	} else if (!vexRT[Btn7L]) {
		minusThetaWristBtnPressed = false;
	}
}

void Arm() {
	//This system controlls all arm movement, such as the main triple extension to the height of our game wires. If a drive mode should have the arms controlled by a driver, then this method should be called
	if (vexRT[Btn6D]) {
		motor[arm] = 127.0;		// If the lower button is pressed, move the arm down
	} else if (vexRT[Btn6U]) {
		motor[arm] = -127;		// If the upper button is pressed, moves arm up
	} else {
		motor[arm] = 0;				// In all other cases, stop the arm. This includes both buttons being pressed and neither buttons being pressed
	}
}


void Arcade() {

	// - Drive Methods -
	//One of two driver controlled drive systems where Ch2 and Ch1, the vertical and horizontal channels on one joystick, determine how to stear the robot, akin to a normal joystick
	if (abs(vexRT[Ch2] - vexRT[Ch1]) > deadband) {//This if statement implements our deadbanding system. When the value we would implement is less than a configured point,
																								//then they are likely imperfections in our joystick. Inputs below this amount are ignored to prevent motor drift
		motor[right] = vexRT[Ch2] - vexRT[Ch1];//Our right motor value should be increase when our drivers intend to move forward, but decrease as they intend to move left.
		} else {
		motor[right] = 0;
	}
	if (abs(vexRT[Ch1] + vexRT[Ch2]) > deadband) {//This if statment preforms the same function as the one above. It is altered to reflect how our left motor value is directly proportional to our Ch1 and Ch2 inputs together,
																								//while the right motors are inversely proportional to Ch1
		motor[left] = vexRT[Ch2] + vexRT[Ch1];//Our left motor value should be increase when our drivers intend to move forward, but decrease as they intend to move left.
		} else {
		motor[left] = 0;
	}

	// - Miscellaneous Arcade Control Methods -
	/*
		Our drive methods often dictate which inputs are avaliable.
		By appending functions to the end of the drive method we can make methods only run on specific drive codes, or make variations of miscellaneous methods that only run on specific drive controls.
	*/
	Arm();
	Wrist();
}

void Tank() {

	// - Drive Methods -
	//One of two driver controlled drive systems where Ch3 and Ch2, the vertical channels on the two joysticks, determine how to stear the robot, as if each joystick directly moved each motor
	if (abs(vexRT[Ch3]) > deadband) { // Checks value of left joystick to see if it's outside of deadband
		motor[left] = vexRT[Ch3];
		} else {
		motor[left] = 0;
	}
	if (abs(vexRT[Ch2]) > deadband) {
		motor[right] = vexRT[Ch2];
		} else {
		motor[right] = 0;
	}
	// - Miscellaneous Tank Control Methods -
	/*
		Our drive methods often dictate which inputs are avaliable.
		By appending functions to the end of the drive method we can make methods only run on specific drive codes, or make variations of miscellaneous methods that only run on specific drive controls.
	*/
	Arm();
	Wrist();
}

bool sensorCheck(long sens) { // sensorCheck takes in the value from a sensor and return whether or not our robot should concider the value returned by a sensor to be either positive or negative, allowing us to treat our inputs as boolean values
	return (sens > 0.5);
}

void GetSensorReadout() {
	/*
	Debugging function that sets values to our sensors to allow us to quickly debug our IR values by allowing us to know what our sensors are outputing.
	RobotC testing mode does not normaly display the values of each sensor, but it can display variables so by assigning the sensors to a variable, it allows us to see our sensors
	If there is a problem with our sensors, beif obeservation on these testing variables while exposing the sensors to the line will reveal if the sensors or their wiring is non-functional
	*/
	sensorLeft = SensorValue[LeftSensor];
	sensorRight = SensorValue[RightSensor];
	sensorAutoCheck = SensorValue[AutoCheck];
}

float MotorCheck(float speed, float change) {
	speed += change;
	if (speed > MaxSpeed) {
		speed = MaxSpeed;
	} else if (speed < MinSpeed) {
		speed = MinSpeed;
	}
	return speed;
}

//This is a function that is called whenever an autonomous run is completed. It is used to reset the motors before the next run.
void PathFinishedReset() { // If the autonomous is finished, the motors should be reset.
	motor[left] = 0;
	motor[right] = 0;
}

/*This autonomous function does not use the IR sensors, which can sometimes be faulty or innacurate.
The robot is placed directly facing the destination and it will move forwards it until colliding with the destination.
This mode is simple and fast with little chance for software error. It is prone to driver error and it is overall less reliable than normal autonomous
This mode works as both a backup system and an alternative option for drivers.
*/
void AlternativeAuto() {
	GetSensorReadout();
	if (SensorValue[sensorAutoCheck] == 1) {
		PathFinishedReset();
	} else {
		motor[left] = 127;
		motor[right] = 127;
	}
}

//During the game, our driver can put down their joysticks and begin an autonomous run. During this time they are unable to control the robot and must let the robot guide itself using its sensors.
void MainAuto() {
	GetSensorReadout(); // Debug funcion to increase visibility of sensor values
	if (SensorValue[sensorAutoCheck] == 1) { //If the forward collision sensor has struck an object, in intended behaviour this is the delivery station and end of autonomous
		PathFinishedReset();
	} else { // While Autonomous should be running
		if (sensorCheck(sensorLeft) && sensorCheck(sensorRight)) {		// If both are detecting black increase the speed to allow rapid completment of the Autonomous section
			LeftSpeed = MotorCheck(LeftSpeed, increment);
			RightSpeed = MotorCheck(RightSpeed, increment);
		} else if (sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){	// If only left is detcting black increase the speed of the right motor while decreasing the speed of the left motor. By weakening the left side of the motor, the robot turns right
			LeftSpeed = MotorCheck(LeftSpeed, -increment);
			RightSpeed = MotorCheck(RightSpeed, increment);
		} else if (!sensorCheck(sensorLeft) && sensorCheck(sensorRight)){	// If only right is detecting black increase the speed of the left motor while decreasing the speed of the right motor. By weakening the right side of the motor, the robot turns left
			LeftSpeed = MotorCheck(LeftSpeed, increment);
			RightSpeed = MotorCheck(RightSpeed, -increment);
		} else if (!sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){		// If neither are detecting black decrease the speed. There are times when neither sensor see the line, we will move slowly under the assumption that we simply moved lightly off track.
			LeftSpeed = MotorCheck(LeftSpeed, -increment);
			RightSpeed = MotorCheck(RightSpeed, -increment);
		}
		//These turn the desired motor values, on a scale of 0-1, to actual motor values, on a scale of 0-127
		motor[left] = LeftSpeed * 127;
		motor[right] = RightSpeed * 127;
	}
}


task main() {

	//Initilisation
	if (!setupComplete) {
		SetupRobot();
		setupComplete = true;
	}

	//Main Logic Loop
	while (true) { // A loop containing all repeating logic for our program that runs indefinitly.

		CheckDriveModes();// Checks and sets the current driveMode based on which buttons are pressed

		switch (driveMode) { // Stateflow which determines where our robot gets inputs from and splits accordingly
		case 0:
			Arcade(); // Two Axis on One Joystick control the movement of the chasis
			break;
		case 1:
			Tank(); //Two Axis on Two seperate Joysticks control the movement of the chasis.
			break;
		case 2:
			MainAuto();//Two IR sensors on the front of the robot determine control by detecting and following lines placed on the gamefield
			break;
		case 3:
			AlternativeAuto();/*(Direct Autonomous)
			The robot moves forward until colliding with the destination where it can deliver the payload.
			While much less elegant, this solution has been sucessfull.
			However it requirs a direct line between the robot and the destination, hince the alias of direct autonomous.
			This system is mainly used if there is a problem with the IR sensors or the main Line-following code, or if our drivers belive that doing so would be more effecent
			break;
			*/
		}
	}
}
