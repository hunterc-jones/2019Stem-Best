#pragma config(Sensor, dgtl2,  LeftSensor,     sensorDigitalIn)
#pragma config(Sensor, dgtl10, AutoCheck,      sensorTouch)
#pragma config(Sensor, dgtl12, RightSensor,    sensorDigitalIn)
#pragma config(Motor,  port2,           left,          tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           arm,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           right,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rake,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           claw,          tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           pushRod,       tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
2019 Off The Grid Final Code
Neccesary Operations:
Arm Motor
-Motor port 3,
-Right side up(6U): Extend
-Right side down(6D): Retract
-Default off
-Motor with purpose of drawing cable into a spool to pull triple extension upwards



*/

// ARM control = up/down LEFT gamepad btns
// CLAW control = left/right RIGHT gamepad btns

// Joystick Control Vars
short RightBumpUpBtn = Btn6U;
short RightBumpDownBtn = Btn6D;

short ActArcadeTankBtn = Btn8U;
short ActMainAutoBtn1 = Btn7L;
short ActMainAutoBtn2 = Btn7R;
short ActAltAutoBtn1 = Btn7U;
short ActAltAutoBtn2 = Btn7D;
short ActShakeBtn1 = Btn8L;
short ActShakeBtn2 = Btn8R;

short ToggleRakeBtn = Btn8D;
short ToggleClawBtn = Btn5U;

short ArcadeAxisY = Ch3;
short ArcadeAxisX = Ch4;

short TankLeftY = Ch3;
short TankRightY = Ch2;


// Autonomous Vars
bool StartingPathFound = false;
long sensorLeft;
long sensorRight;
int sensorAutoCheck;
float MaxSpeed = 0.8;					// CONFIG VAL		for setting highest speed robot can increment to during autonomous
float increment = 0.01;				// CONFIG VAL		for setting the speed robot makes each iteration during autonomou
float MinSpeed = -MaxSpeed;
float LeftSpeed;
float RightSpeed;
short pushRodSetupAngle = -14;
short pushRodClampAngle = -23;
short pushRodReleaseAngle = 80;
short extendArmTime = 250;		// CONFIG VAL 	amount of ms the arm goes up to prepare for autonomous
float autoLeftSpeed = 0.8;		// CONFIG VAL		percentage of left motor speed from 127
float autoRightSpeed = 1.0;		// CONFIG VAL		percentage of right motor speed from 127
short autoReleasePushrodTime = 1200; 				// CONFIG VAL

// Basis Vars
int driveMode = 0;
int rememberWheelDrive;
//int InitDriverMotorFowardTime = 3000;			// CONFIG VAL									3 seconds (3000 ms)
bool arcadeToggle = false;				// DEFAULT = TANK
bool setupComplete = false;
bool arcadeBtnPressed = false;
bool mainautoBtnPressed = false;
bool AlternateAutoBtnPressed = false;
float deadband = 1.0;					// CONFIG VAL to reduce deadband

// Arm, Claw, Rake Vars
bool clawToggle;
bool plusThetaClawBtnPressed = false;
int clawAngleClose = -120;
int clawAngleOpen = -30;
/*
bool deployElbow = false;
float elbowPot = 0.0;
bool elbowCheck = true;
float elbowPercentIncrease = 2.3;
int elbowDownSpeed = 0.5;
*/
bool rakeBtnPressed = false;
bool rakeToggle = true;
int rakeAngleClose = 25;
int rakeAngleOpen = 127;

// Random 'ShakeTheCrapOutOfRobot' Stuff
int leftMotorVal;
int rightMotorVal;
int armMotorVal;
int pushrodServoVal;
int rakeServoVal;
int clawServoVal;
bool shakeOutBtnPressed = false;
bool shakeToggle = false;





void InitRobot() {
	if (!setupComplete) {
		motor[claw] = clawAngleOpen;	// min 40, max -120
		motor[pushRod] = pushRodSetupAngle;
		StartingPathFound = false;
		setupComplete = true;
	}
}

void CheckDriveModes() {
		// Activate arcade or tank
	if (vexRT[ActArcadeTankBtn] && !arcadeBtnPressed) {
		if (driveMode!=0&&driveMode!=1) {			// if not already in tank or arcade
			driveMode = rememberWheelDrive;
		} else if (driveMode==0||driveMode==1) {		// if already in tank or arcade
			if (arcadeToggle == true) {
				driveMode = 0;		// Arcade drivemode
				arcadeToggle = false;
			} else if (arcadeToggle == false) {
				driveMode = 1;		// Tank drivemode
				arcadeToggle = true;
			}
		}
		rememberWheelDrive = driveMode;
		arcadeBtnPressed = true;
	} else if (!vexRT[ActArcadeTankBtn]) {
		arcadeBtnPressed = false;
	}
		// Activate main auto or Ralsty auto
	if (    (vexRT[ActMainAutoBtn1]&&vexRT[ActMainAutoBtn2])    &&    (  (!mainautoBtnPressed && !vexRT[ActAltAutoBtn1])  &&  !vexRT[ActAltAutoBtn2])    ) {
		driveMode = 2;
		mainautoBtnPressed = true;
	} else if (!vexRT[ActMainAutoBtn1]&&!vexRT[ActMainAutoBtn2]) {
		mainautoBtnPressed = false;
	}
	if (	(vexRT[ActAltAutoBtn1]&&vexRT[ActAltAutoBtn2])	&&	(	(!AlternateAutoBtnPressed && !vexRT[ActMainAutoBtn1])	&&!vexRT[ActMainAutoBtn2])	) {
		driveMode = 3;
		AlternateAutoBtnPressed = true;
	} else if (!vexRT[ActAltAutoBtn1]&&!vexRT[ActAltAutoBtn2]) {
		AlternateAutoBtnPressed = false;
	}
}

int genRandVal(int motorVal) {
	motorVal = random(255);		// because (127*2) + 1 to account for exclusion
	return (motorVal-127);		// to half range, since random() can only gen positive range
}

void ShakeParty() {
	// if LEFT AND RIGHT btns on RIGHT gamepad are pressed while all other RIGHT gamepad btns are not being pressed (in case by accident)
	if (vexRT[ActShakeBtn1]&&vexRT[ActShakeBtn2]&&!shakeOutBtnPressed&&!vexRT[ActArcadeTankBtn]&&!vexRT[ToggleRakeBtn]) {
		// toggle to SHAKE or NOT SHAKE
		if (!shakeToggle) shakeToggle=true;
		if (shakeToggle) shakeToggle=false;
		shakeOutBtnPressed = true;
	} else if (!vexRT[ActShakeBtn1]&&!vexRT[ActShakeBtn2]) {
		shakeOutBtnPressed = false;
	}
	if (shakeToggle == true) {
		srand(2378);		// random value of BEST

		//Motors
		motor[left] = genRandVal(leftMotorVal);
		motor[arm] = genRandVal(rightMotorVal);
		motor[right] = genRandVal(armMotorVal);

		//Servos
		motor[claw] = genRandVal(pushrodServoVal);
		motor[rake] = genRandVal(rakeServoVal);
		motor[pushRod] = genRandVal(clawServoVal);
	}
}

void Claw() {
	if (vexRT[ToggleClawBtn] && !plusThetaClawBtnPressed) {
		if (clawToggle == true) {
			motor[claw] = clawAngleOpen;
			clawToggle = false;
		} else if (!clawToggle) {
			motor[claw] = clawAngleClose;
			clawToggle = true;
		}
		plusThetaClawBtnPressed = true;
	} else if (!vexRT[ToggleClawBtn]) {
		plusThetaClawBtnPressed = false;
	}
}

void Arm() {		// function for arm and elbow (elbow if configured for Corbin's design)
	if (vexRT[RightBumpDownBtn]) {											// relative DOWN btn
		motor[arm] = 127.0;		// moves arm down
	} else if (vexRT[RightBumpUpBtn]) {							// relative UP btn
		motor[arm] = -127;		// moves arm up
	} else {
		motor[arm] = 0;				// stops arm
	}
	/*
	if (vexRT[Btn7U]) deployElbow = true;
		if (vexRT[Btn7D]) deployElbow = false;

		elbowPot = SensorValue[elbowPotSensor];

		if (deployElbow) {
			elbowCheck = false;
			motor[elbow] = (elbowPot - 2716) / 12;
		} else {
			if (!elbowCheck) {
				if (elbowPot > 1000) {
					motor[elbow] = -15*elbowPercentIncrease;
				} else {
					motor[elbow] = 8*elbowPercentIncrease;
				}
				elbowCheck = elbowPot - 4094 > -20;
			} else {
				if (motor[elbow] > 0) {
					motor[elbow] -= elbowDownSpeed;
				} else {
					motor[elbow] = 0;
				}
			}
	}
	*/
}
void Rake() {
	if (vexRT[ToggleRakeBtn] && !rakeBtnPressed) {
		if (rakeToggle == true) {
			rakeToggle = false;
		} else if (rakeToggle == false) {
			rakeToggle = true;
		}
		rakeBtnPressed = true;
	} else if (!vexRT[ToggleRakeBtn]) {
		rakeBtnPressed = false;
	}
	if (rakeToggle) motor[rake] = rakeAngleClose;
	if(!rakeToggle) motor[rake] = rakeAngleOpen;
}
void ManualControls() {
	Arm();
	Claw();
	Rake();
	ShakeParty();
}

void Arcade() {
	InitRobot();
	if (abs(vexRT[ArcadeAxisY] - vexRT[ArcadeAxisX]) > deadband) {
		motor[right] = vexRT[ArcadeAxisY] - vexRT[ArcadeAxisX];
	} else {
		motor[right] = 0;
	}
	if (abs(vexRT[ArcadeAxisX] + vexRT[ArcadeAxisY]) > deadband) {
		motor[left] = vexRT[ArcadeAxisX] + vexRT[ArcadeAxisY];
	} else {
		motor[left] = 0;
	}
	ManualControls();
}
void Tank() {
	InitRobot();
	if (abs(vexRT[TankLeftY]) > deadband) { // Checks value of left joystick to see if it's outside of deadband
		motor[left] = vexRT[TankLeftY];
		} else {
		motor[left] = 0;
	}
	if (abs(vexRT[TankRightY]) > deadband) {
		motor[right] = vexRT[TankRightY];
		} else {
		motor[right] = 0;
	}
	ManualControls();
}









bool sensorCheck(long sens) {
	return (sens > 0.5);
}
void GetSensorReadout() {
	setupComplete = false;
	sensorLeft = SensorValue[LeftSensor];
	sensorRight = SensorValue[RightSensor];
	sensorAutoCheck = SensorValue[AutoCheck];
}
float MotorCheck(float speed, float change) {
	speed += change;
	if (speed > MaxSpeed) {
		speed = MaxSpeed;
	} else if (speed < MinSpeed) {
		speed = MinSpeed;
	}
	return speed;
}

void PathFinishedReset() {
	motor[left] = 0;
	motor[right] = 0;
	motor[pushRod] = 	pushRodReleaseAngle;
	delay(autoReleasePushrodTime);				// Auto release pushrod time
	driveMode = 0;
}

void PrepareAuto() {
	motor[rake] = rakeAngleOpen;
	rakeToggle = false;
	motor[pushRod] = pushRodClampAngle;
	motor[arm] = -127;
	delay(extendArmTime);
}

void AlternateAuto() {
	GetSensorReadout();
	if (!StartingPathFound) {
		PrepareAuto();
		StartingPathFound = true;
	} else {
		if (sensorAutoCheck == 0) {
			PathFinishedReset();
		} else {
			motor[left] = 127 -52;
			motor[right] = 127;
		}
	}
}

void MainAuto() {
	GetSensorReadout();
	if (!StartingPathFound) {
		PrepareAuto();
		StartingPathFound = true;
	} else {
		if (sensorAutoCheck == 0) {
			PathFinishedReset();
		} else {
			if (sensorCheck(sensorLeft) && sensorCheck(sensorRight)) {		// If both are detecting black
				LeftSpeed = MotorCheck(LeftSpeed, increment);
				RightSpeed = MotorCheck(RightSpeed, increment);
			} else if (sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){	// If only left is detcting black
				LeftSpeed = MotorCheck(LeftSpeed, increment);
				RightSpeed = MotorCheck(RightSpeed, -increment);
			} else if (!sensorCheck(sensorLeft) && sensorCheck(sensorRight)){	// If only right is detecting black
				LeftSpeed = MotorCheck(LeftSpeed, -increment);
				RightSpeed = MotorCheck(RightSpeed, increment);
			} else if (!sensorCheck(sensorLeft) && !sensorCheck(sensorRight)){		// If neither are detecting black
				LeftSpeed = MotorCheck(LeftSpeed, -increment);
				RightSpeed = MotorCheck(RightSpeed, -increment);
			}
			motor[left] = (LeftSpeed * 127) * autoLeftSpeed;
			motor[right] = RightSpeed * 127 * autoRightSpeed;
		}
	}
}


task main() {
	InitRobot();

	while (true) {
	/*
	Main Loop
	A continuosly running while loop inwhich contains all contunaly activating methods for our robot.
	All methods must be repeatedly run or else robot will be unable to react to changing stimuli.

	*/
		// Checks for button presses and sets drive mode accordingly
		CheckDriveModes();

		//Testing
		GetSensorReadout();

		switch (driveMode) { // Switch case to allow a varition of inputs to be switched between to fit driver needs and completion of autonomous challenges
		case 0:
			Arcade();//Arcade mode is where two analog inputs from one joystick is used
			break;
		case 1:
			Tank();//Tank mode is where two vertical inputs from two seperate joysticks are converted into motor values
			break;
		case 2:
			MainAuto();//Arcade mode is where the robot is controled by our sensors. This is the primary arcade mode where the robot is guided by IR drives
			break;
		case 3:
			AlternateAuto();//RalstonValley automatic
			break;
		}
	}
}
